<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Qpid Proton C++: Multi-threading</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qpid Proton C++
   &#160;<span id="projectnumber">0.18.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('mt_page.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Multi-threading </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Full multi-threading support is available with C++11 and later. Limited multi-threading is possible with older versions of C++, see the final section of this page.</p>
<p><code><a class="el" href="classproton_1_1message.html" title="An AMQP message. ">proton::message</a></code> is a value type with the same threading constraints as a standard C++ built-in type, it cannot be concurrently modified.</p>
<p>The <code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, senders, and receivers. ">proton::container</a></code> is thread safe <em>with C++11 or greater</em>. It provides the following:</p>
<ul>
<li>User threads can open (or listen for) new connections at any time.</li>
<li>Manages worker threads to process connections.</li>
<li>Handles network IO and calls the relevant <code>proton::messaging_handler::on_xxx</code> event callbacks that can be over-ridden by user code.</li>
</ul>
<p>The <code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, senders, and receivers. ">proton::container</a></code> ensures that calls to event callbacks for each connection instance are <em>serialized</em> (not called concurrently), but callbacks for different connections may be called in parallel.</p>
<dl class="section note"><dt>Note</dt><dd>The <code><a class="el" href="classproton_1_1connection.html" title="A connection to a remote AMQP peer. ">proton::connection</a></code> and related objects (<code><a class="el" href="classproton_1_1session.html" title="A container of senders and receivers. ">proton::session</a></code>, <code><a class="el" href="classproton_1_1sender.html" title="A channel for sending messages. ">proton::sender</a></code>, <code><a class="el" href="classproton_1_1receiver.html" title="A channel for receiving messages. ">proton::receiver</a></code>, <code><a class="el" href="classproton_1_1delivery.html" title="A received message. ">proton::delivery</a></code>) are <em>not</em> thread safe, and are subject to the following rules:</dd></dl>
<ol type="1">
<li>They may only be used from a <code><a class="el" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events. ">proton::messaging_handler</a></code> event callback called by proton (or a <code><a class="el" href="classproton_1_1work__queue.html" title="Unsettled API - A work queue for serial execution. ">proton::work_queue</a></code> function, more below)</li>
<li>You can't use objects belonging to one connection in a callback for a different connection. We recommend a single handler instance per connection to avoid confusion.</li>
<li>You can store proton objects in member variables for use in a later callback, provided you respect 2.</li>
</ol>
<p>The <code><a class="el" href="classproton_1_1work__queue.html" title="Unsettled API - A work queue for serial execution. ">proton::work_queue</a></code> provides a safe way to communicate between different connection handlers or between non-proton threads and connection handlers.</p>
<ul>
<li>Each connection has an associated <code><a class="el" href="classproton_1_1work__queue.html" title="Unsettled API - A work queue for serial execution. ">proton::work_queue</a></code></li>
<li>The work queue is thread safe (C++11 or greater), any thread can add work.</li>
<li>"work" is a <code>std::function</code> and bound arguments to be called like an event callback.</li>
</ul>
<p>When the work function is called by proton, it will be serialized safely so that you can treat the work function like an event callback and safely access the handler and proton objects stored on it.</p>
<p>The examples <a class="el" href="multithreaded_client_8cpp-example.html">multithreaded_client.cpp</a> and <a class="el" href="multithreaded_client_flow_control_8cpp-example.html">multithreaded_client_flow_control.cpp</a> show how you can send/receive messages from non-proton threads using these techniques.</p>
<h2>The wake primitive</h2>
<p><code><a class="el" href="classproton_1_1connection.html#a473371542eaeba6f67660582fe6a6074" title="Unsettled API - trigger an event from another thread ">proton::connection::wake()</a></code> allows any thread to "wake up" a connection by generating a <code><a class="el" href="classproton_1_1messaging__handler.html#a29bfba2d26604e5d8d7f3183f1374481" title="Unsettled API - an event that can be triggered from another thread. ">proton::messaging_handler::on_connection_wake()</a></code> callback. This is the <em>only</em> thread-safe <code><a class="el" href="classproton_1_1connection.html" title="A connection to a remote AMQP peer. ">proton::connection</a></code> function.</p>
<p>This is a light-weight, low-level primitive for signalling between threads:</p>
<ul>
<li>It does not carry any code or data (unlike <code><a class="el" href="classproton_1_1work__queue.html" title="Unsettled API - A work queue for serial execution. ">proton::work_queue</a></code>)</li>
<li>Multiple calls to wake() can be "coalesced" into a single <code><a class="el" href="classproton_1_1messaging__handler.html#a29bfba2d26604e5d8d7f3183f1374481" title="Unsettled API - an event that can be triggered from another thread. ">proton::messaging_handler::on_connection_wake()</a></code></li>
<li>There may be calls to <code><a class="el" href="classproton_1_1messaging__handler.html#a29bfba2d26604e5d8d7f3183f1374481" title="Unsettled API - an event that can be triggered from another thread. ">proton::messaging_handler::on_connection_wake()</a></code> occur without any call to <code>connection::wake()</code>, generated internally by the library.</li>
</ul>
<p>The semantics of <code>wake()</code> are similar to <code>std::condition_variable::notify_one</code>: there will be a wakeup, but there must be some shared application state to determine why the wakeup occurred and what, if anything, to do about it.</p>
<p><code><a class="el" href="classproton_1_1work__queue.html" title="Unsettled API - A work queue for serial execution. ">proton::work_queue</a></code> is easier to use in many instances, but <code>wake()</code> may be useful if you already have your own external thread-safe queues and just need an efficient way to wake a connection to check them for data.</p>
<h2>Using older versions of C++</h2>
<p>Before C++11 there was no standard support for threading in C++. You can use proton with threads but with limitations:</p>
<ul>
<li>The container will not create threads, it will only use the single thread that calls <a class="el" href="classproton_1_1container.html#a13a43e6d814de94978c515cb084873b1" title="Run the container in this thread. ">proton::container::run()</a></li>
<li>None of the proton library classes are thread-safe, including <a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, senders, and receivers. ">proton::container</a> and <a class="el" href="classproton_1_1work__queue.html" title="Unsettled API - A work queue for serial execution. ">proton::work_queue</a>. You need an external lock to use <a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, senders, and receivers. ">proton::container</a> in multiple threads.</li>
</ul>
<p>The only exception is <code><a class="el" href="classproton_1_1connection.html#a473371542eaeba6f67660582fe6a6074" title="Unsettled API - trigger an event from another thread ">proton::connection::wake()</a></code>, it <em>is</em> thread safe even in older C++.</p>
<p>You can implement your own <code><a class="el" href="classproton_1_1container.html" title="A top-level container of connections, sessions, senders, and receivers. ">proton::container</a></code> using your own threading library, or ignore the container and embed the lower-level <code>proton::connection_engine</code> in an external poller. These approaches still use the same <code><a class="el" href="classproton_1_1messaging__handler.html" title="A handler for Proton messaging events. ">proton::messaging_handler</a></code> callbacks, so you can re-use most of your application code. This is an advanced undertaking, there are a few pointers on <a class="el" href="io_page.html">IO integration</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
